<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/commands/dispatcher.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Gawdl3y/discord-graf.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/config.js~BotConfig.html">BotConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~GrafBot.html">GrafBot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/permissions.js~BotPermissions.html">BotPermissions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util.js~BotUtil.html">BotUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-version">version</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ConfigObject">ConfigObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-PatternConstants">PatternConstants</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">commands</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/commands/command.js~Command.html">Command</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/commands/dispatcher.js~CommandDispatcher.html">CommandDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/commands/registry.js~CommandRegistry.html">CommandRegistry</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/allowed-channels.js~AllowedChannelStorage.html">AllowedChannelStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/mod-roles.js~ModRoleStorage.html">ModRoleStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/settings.js~SettingStorage.html">SettingStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/storage.js~Storage.html">Storage</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data/models</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/models/setting.js~Setting.html">Setting</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">errors</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors/command-format.js~CommandFormatError.html">CommandFormatError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors/friendly.js~FriendlyError.html">FriendlyError</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/commands/dispatcher.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use babel&apos;;
&apos;use strict&apos;;

import stringArgv from &apos;string-argv&apos;;
import { stripIndents } from &apos;common-tags&apos;;
import escapeRegex from &apos;escape-string-regexp&apos;;
import FriendlyError from &apos;../errors/friendly&apos;;

export default class CommandDispatcher {
	constructor(client, registry, settings, config, logger) {
		if(!client || !registry || !config || !settings) throw new Error(&apos;client, registry, settings, and config must be specified.&apos;);
		this.client = client;
		this.registry = registry;
		this.settings = settings;
		this.config = config;
		this.logger = logger;
		this._serverCommandPatterns = {};
		this._results = {};
	}

	async handleMessage(message, oldMessage = null) {
		if(message.author.equals(this.client.user)) return;

		// Make sure the bot is allowed to run in the channel, or the user is an admin
		if(message.server &amp;&amp; !this.settings.isEmpty(message.server)
			&amp;&amp; !this.settings.exists(message.server, message.channel)
			&amp;&amp; !this.permissions.isAdmin(message.server, message.author)) return;

		// Parse the message, and get the old result if it exists
		const [command, args, fromPattern, isCommandMessage] = this.parseMessage(message);
		const oldResult = oldMessage ? this.results[oldMessage.id] : null;

		// Run the command, or make an error message result
		let result;
		if(command) {
			if(!oldMessage || oldResult) result = this.constructor.makeResultObject(await this.run(command, args, fromPattern, message));
		} else if(isCommandMessage) {
			result = { reply: [`Unknown command. Use ${this.util.usage(&apos;help&apos;, message.server)} to view the list of all commands.`], editable: true };
		} else if(this.config.nonCommandEdit) {
			result = {};
		}

		if(result) {
			// Change a plain or reply response into direct if there isn&apos;t a server
			if(!message.server) {
				if(!result.direct) result.direct = result.plain || result.reply;
				delete result.plain;
				delete result.reply;
			}

			// Update old messages or send new ones
			if(oldResult &amp;&amp; (oldResult.plain || oldResult.reply || oldResult.direct)) {
				await this.updateMessagesForResult(message, result, oldResult);
			} else {
				await this.sendMessagesForResult(message, result);
			}

			// Cache the result
			if(this.config.values.commandEditable &gt; 0) {
				if(result.editable) {
					result.timeout = oldResult &amp;&amp; oldResult.timeout ? oldResult.timeout : setTimeout(() =&gt; { delete this.results[message.id]; }, this.config.values.commandEditable * 1000);
					this.results[message.id] = result;
				} else {
					delete this.results[message.id];
				}
			}
		}
	}

	async run(command, args, fromPattern, message) {
		const logInfo = {
			args: String(args),
			user: `${message.author.username}#${message.author.discriminator}`,
			userID: message.author.id,
			server: message.server ? message.server.name : null,
			serverID: message.server ? message.server.id : null
		};

		// Make sure the command is usable
		if(command.serverOnly &amp;&amp; !message.server) {
			if(this.logger) this.logger.info(`Not running ${command.group}:${command.groupName}; server only.`, logInfo);
			return `The \`${command.name}\` command must be used in a server channel.`;
		}
		if(command.isRunnable &amp;&amp; !command.isRunnable(message)) {
			if(this.logger) this.logger.info(`Not running ${command.group}:${command.groupName}; not runnable.`, logInfo);
			return `You do not have permission to use the \`${command.name}\` command.`;
		}

		// Run the command
		if(this.logger) this.logger.info(`Running ${command.group}:${command.groupName}.`, logInfo);
		try {
			return await command.run(message, args, fromPattern);
		} catch(err) {
			if(err instanceof FriendlyError) {
				return err.message;
			} else {
				if(this.logger) this.logger.error(err);
				const owner = this.config.values.owner ? message.client.users.get(&apos;id&apos;, this.config.values.owner) : null;
				return stripIndents`
					An error occurred while running the command: \`${err.name}: ${err.message}\`
					${owner ? `Please contact ${owner.name}#${owner.discriminator}${this.config.values.invite ? ` in this server: ${this.config.values.invite}` : &apos;.&apos;}` : &apos;&apos;}
				`;
			}
		}
	}

	async sendMessagesForResult(message, result) {
		const messages = await Promise.all([
			result.plain ? this.sendMessages(message, result.plain, &apos;plain&apos;) : null,
			result.reply ? this.sendMessages(message, result.reply, &apos;reply&apos;) : null,
			result.direct ? this.sendMessages(message, result.direct, &apos;direct&apos;) : null
		]);
		if(result.plain) result.normalMessages = messages[0];
		else if(result.reply) result.normalMessages = messages[1];
		if(result.direct) result.directMessages = messages[2];
	}

	async sendMessages(message, contents, type) {
		const sentMessages = [];
		for(const content of contents) {
			if(type === &apos;plain&apos;) sentMessages.push(await message.client.sendMessage(message, content));
			else if(type === &apos;reply&apos;) sentMessages.push(await message.reply(content));
			else if(type === &apos;direct&apos;) sentMessages.push(await message.client.sendMessage(message.author, content));
		}
		return sentMessages;
	}

	async updateMessagesForResult(message, result, oldResult) {
		// Update the messages
		const messages = await Promise.all([
			result.plain || result.reply ? this.updateMessages(message, oldResult.normalMessages, result.plain ? result.plain : result.reply, result.plain ? &apos;plain&apos; : &apos;reply&apos;) : null,
			result.direct ? oldResult.direct ? this.updateMessages(message, oldResult.directMessages, result.direct, &apos;direct&apos;) : this.sendMessages(message, result.direct, &apos;direct&apos;) : null
		]);
		if(result.plain || result.reply) result.normalMessages = messages[0];
		if(result.direct) result.directMessages = messages[1];

		// Delete old messages if we&apos;re not using them
		if(!result.plain &amp;&amp; !result.reply &amp;&amp; (oldResult.plain || oldResult.reply)) for(const msg of oldResult.normalMessages) msg.delete();
		if(!result.direct &amp;&amp; oldResult.direct) for(const msg of oldResult.directMessages) msg.delete();
	}

	async updateMessages(message, oldMessages, contents, type) {
		const updatedMessages = [];

		// Update/send messages
		for(let i = 0; i &lt; contents.length; i++) {
			if(i &lt; oldMessages.length) updatedMessages.push(await oldMessages[i].update(type === &apos;reply&apos; ? `${message.author}, ${contents[i]}` : contents[i]));
			else updatedMessages.push((await this.sendMessages(message, [contents[i]], type))[0]);
		}

		// Delete extra old messages
		if(oldMessages.length &gt; contents.length) {
			for(let i = oldMessages.length - 1; i &gt;= contents.length; i--) oldMessages[i].delete();
		}

		return updatedMessages;
	}

	parseMessage(message) {
		// Find the command to run by patterns
		for(const command of this.registry.commands) {
			if(!command.patterns) continue;
			for(const pattern of command.patterns) {
				const matches = pattern.exec(message.content);
				if(matches) return [command, matches, true, true];
			}
		}

		// Find the command to run with default command handling
		const patternIndex = message.server ? message.server.id : &apos;-&apos;;
		if(!this._serverCommandPatterns[patternIndex]) this._serverCommandPatterns[patternIndex] = this._buildCommandPattern(message.server, message.client.user);
		let [command, args, isCommandMessage] = this.matchDefault(message, this._serverCommandPatterns[patternIndex], 2);
		if(!command &amp;&amp; !message.server) [command, args, isCommandMessage] = this.matchDefault(message, unprefixedCommandPattern);
		if(command) return [command, args, false, true];

		return [null, null, false, isCommandMessage];
	}

	matchDefault(message, pattern, commandNameIndex = 1) {
		const matches = pattern.exec(message.content);
		if(!matches) return [null, null, false];

		const commandName = matches[commandNameIndex].toLowerCase();
		const command = this.registry.commands.find(cmd =&gt; cmd.name === commandName || (cmd.aliases &amp;&amp; cmd.aliases.some(alias =&gt; alias === commandName)));
		if(!command || command.disableDefault) return [null, null, true];

		const argString = message.content.substring(matches[1].length + (matches[2] ? matches[2].length : 0));
		let args;
		if(!(&apos;argsType&apos; in command) || command.argsType === &apos;single&apos;) {
			args = [argString.trim()];
		} else if(command.argsType === &apos;multiple&apos;) {
			if(&apos;argsCount&apos; in command) {
				if(command.argsCount &lt; 2) throw new RangeError(`Command ${command.group}:${command.groupName} argsCount must be at least 2.`);
				args = [];
				const newlinesReplaced = argString.trim().replace(newlinesPattern, newlinesReplacement);
				const argv = stringArgv(newlinesReplaced);
				if(argv.length &gt; 0) {
					for(let i = 0; i &lt; command.argsCount - 1; i++) args.push(argv.shift());
					if(argv.length &gt; 0) args.push(argv.join(&apos; &apos;).replace(newlinesReplacementPattern, &apos;\n&apos;).replace(extraNewlinesPattern, &apos;\n\n&apos;));
				}
			} else {
				args = stringArgv(argString);
			}
		} else {
			throw new Error(`Command ${command.group}:${command.groupName} argsType is not one of &apos;single&apos; or &apos;multiple&apos;.`);
		}

		return [command, args, true];
	}

	static makeResultObject(result) {
		if(typeof result !== &apos;object&apos; || Array.isArray(result)) result = { reply: result };
		if(result.plain &amp;&amp; result.reply) throw new Error(&apos;The command result may contain either &quot;plain&quot; or &quot;reply&quot;, not both.&apos;);
		if(result.plain &amp;&amp; !Array.isArray(result.plain)) result.plain = [result.plain];
		if(result.reply &amp;&amp; !Array.isArray(result.reply)) result.reply = [result.reply];
		if(result.direct &amp;&amp; !Array.isArray(result.direct)) result.direct = [result.direct];
		if(!(&apos;editable&apos; in result)) result.editable = true;
		return result;
	}

	/**
	 * Creates a regular expression to match the command prefix and name in a message
	 * @param {?Server} server - A Discord.js Server instance of the server that the message is from
	 * @param {User} user - The Discord.js User instance of the bot
	 * @return {RegExp} Regular expression that matches a command prefix and name
	 */
	_buildCommandPattern(server, user) {
		let prefix = server ? this.settings.getValue(&apos;command-prefix&apos;, this.config.commandPrefix, server) : this.config.commandPrefix;
		if(prefix === &apos;none&apos;) prefix = &apos;&apos;;
		const escapedPrefix = escapeRegex(prefix);
		const prefixPatternPiece = prefix ? `${escapedPrefix}\\s*|` : &apos;&apos;;
		const pattern = new RegExp(`^(${prefixPatternPiece}&lt;@!?${user.id}&gt;\\s+(?:${escapedPrefix})?)([^\\s]+)`, &apos;i&apos;);
		if(this.logger) {
			this.logger.info(`Server command pattern built.`, {
				server: server ? server.name : null,
				serverID: server ? server.id : null,
				prefix: prefix, pattern: pattern.source
			});
		}
		return pattern;
	}
}

const unprefixedCommandPattern = /^([^\s]+)/i;
const newlinesPattern = /\n/g;
const newlinesReplacement = &apos;{!~NL~!}&apos;;
const newlinesReplacementPattern = new RegExp(newlinesReplacement, &apos;g&apos;);
const extraNewlinesPattern = /\n{3,}/g;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
